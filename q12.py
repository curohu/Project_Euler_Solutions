# 04/19/2022

# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?

from datetime import datetime
from numba import jit, numba, prange

@numba.jit(parallel=True,nopython=True)
def getTNumberThread(idx,tget):
    fnd = False
    divz = 0
    sTotal = 0
    for i in range(1,idx+1):
        sTotal += i
    for n in prange(1,sTotal+1):
        if (sTotal%n) == 0:
            divz += 1
    fnd = (divz >= tget)
    return fnd, sTotal, divz

@numba.jit(nopython=True)
def main():
    target = 500
    index = 0
    found = False
    sumTotal = 0
    divisors = 0

    while not found:
        index += 1
        found, sumTotal, divisors = getTNumberThread(index,target)

    print(index,sumTotal,divisors)

if __name__ == "__main__":
    sTime = datetime.now()
    main()
    print(datetime.now()-sTime)

# 12375 76576500 576
# 0:01:05.999030


# TARGET = 200
# index = 0
# found = False
# sumTotal = 0
# chunkSize = 1000
# threads = 10
# divisors = list()
# sTime = datetime.now()

# #@numba.jit(nopython=True)
# def getTNumberThread(searchRnge):
#     found = False
#     index = 0
#     for x in searchRnge:
#         divisors = list()
#         sumTotal = 0
#         for i in range(1,x+1):
#             sumTotal += i
#         for n in range(1,sumTotal+1):
#             if (sumTotal%n) == 0:
#                 divisors.append(n)
#         if len(divisors) >= TARGET:
#             found = True
#             index = x
#             break
#     return found, index, sumTotal, divisors




# while not found:
#     searchRanges = list()
#     for rnge in range(threads):
#         searchRanges.append(range(index,index+chunkSize))
#         index += chunkSize
#     with ThreadPoolExecutor(max_workers=threads) as executor:
#         results = executor.map(getTNumberThread, searchRanges, timeout=30)
#     for result in results:
#         f, searchIndex, st, divz = result
#         if f:
#             divisors = divz
#             print(searchIndex,st,len(divisors), datetime.now()-sTime)
#             sys.exit()
